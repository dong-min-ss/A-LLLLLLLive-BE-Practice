pipeline {
    agent any
    
    environment {
        // AWS 계정 번호와 리전을 젠킨스 변수로 관리 (하드코딩 방지)
        AWS_ACCOUNT_ID = credentials('AWS_ACCOUNT_ID')
        AWS_REGION     = 'ap-northeast-2' 
        ECR_REGISTRY   = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        IMAGE_NAME     = 'olive-backend'
        TAG            = "v${BUILD_NUMBER}" // 빌드 번호를 태그로 사용해 버전 자동 관리
		    SERVER_IP      = '192.168.200.32' // 실제 운영 서버 IP로 변경
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('AWS ECR Login') {
            steps {
                // 젠킨스에 등록한 AWS Access Key/Secret Key를 사용하여 로그인
                withAWS(credentials: 'aws-credentials-id', region: "${AWS_REGION}") {
                    sh "aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}"
                }
            }
        }

        stage('Build and Push') {
            steps {
                // 멀티 플랫폼 빌드 및 ECR 푸시
                dir('aL7ive') { 
                    sh "docker buildx build --platform linux/amd64,linux/arm64 \
                        -t ${ECR_REGISTRY}/${IMAGE_NAME}:${TAG} \
                        -t ${ECR_REGISTRY}/${IMAGE_NAME}:latest . --push"
                }
            }
        }
        
        stage('Deploy') {
            steps {
                // SSH를 통해 운영 서버에 접속하여 배포 실행
                sshagent(['target-server-ssh-key']) {
                    sh """
                    ssh -o StrictHostKeyChecking=no ubuntu@${SERVER_IP} '
                        # 1. ECR 로그인
                        aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        
                        # 2. 기존 컨테이너 중지 및 삭제
                        docker rm -f ${IMAGE_NAME} || true
                        
                        # 3. 새 이미지 가져오기 및 실행
                        docker pull ${ECR_REGISTRY}/${IMAGE_NAME}:${TAG}
                        docker run -d -p 8080:8080 --name ${IMAGE_NAME} ${ECR_REGISTRY}/${IMAGE_NAME}:${TAG}
                        
                        # 4. 사용하지 않는 오래된 이미지 정리
                        docker image prune -f
                    '
                    """
                }
            }
        }

        stage('Cleanup') {
            steps {
                // 빌드 후 로컬에 남은 이미지 정리
                sh "docker rmi ${ECR_REGISTRY}/${IMAGE_NAME}:${TAG} || true"
            }
        }
    }
}
